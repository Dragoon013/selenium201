<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Sauce Laboratories - Selenium 201 </title>

		<meta name="description" content="Learn and practice advanced Selenium concepts with Sauce Labs">
		<meta name="author" content="Jacob Teal">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sauce.css" id="theme">

        <!--favicon-->
        <link rel="shortcut icon" href="assets/images/sauce_favicon.ico" type="image/x-icon" />

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

	  <div class="reveal">

        <style>
          .reveal .slides { text-align: left; }
          .reveal .slides h1 { text-align: center; }
          .reveal .slides h2 { text-align: center; }
          .reveal .slides h3 { text-align: center; font-variant: none; text-transform: none;}
        </style>
		<!-- Any section element inside of this container is displayed as a slide -->

        <img src="assets/images/saucelabslogo.png" style="border:0; width:100px; height:100px; background:none; position:absolute; left:0; top:0;">
        <img id="lab_pic" src="assets/images/Laboratory2.png" style="visibility:hidden; border:0; width:200px; height:200px; background:none; position:absolute; right:0; top:0;">
        <img id="darksauce" src="assets/images/eggs/DarkSauce.png" style="visibility:hidden; border:0; width:500px; height:500px; background:none; position:absolute;">

        <div class="footer">
          <font size="1">© Copyright 2016 by ServiceRocket, Inc | Confidential | Prepared for Sauce Labs</font>
        </div>

	        <div class="slides">

              <section data-background="rgb(226, 35, 26)">
                <h1>Selenium 201</h1>

                <p style="text-align:center">
	              <small><i>Testing at the speed of awesome</i></small>
                </p>
              </section>

              <section>
 <!--IF JACOB IS TEACHING-->

		<!--<h3>Trainer Intro</h3>

                    <div style="float:left;width:50%;" class="centered">
                      <p>
                      <strong>Jacob Teal</strong>
                      <p>Technology Consultant</p>
                      <p>B.A. Computational Mathematics</p>
                      <p><a href="mailto:jacob.teal@servicerocket.com">jacob.teal@servicerocket.com</a></p>
					  </p>
                    </div>

                    <div style="float:right;width:40%;padding-right:0px;">
                      <img src="assets/images/starfish.png" style="border:0;background:none; left:0; top:0;">
                    </div>
				</section>

              <section>
                <h3>Course Administration</h3>
                <ul>
                  <li>This session is ~3 hours long</li>
                  <ul><li>10 min. breaks every hour</li></ul>
                  <li>Slides, demonstrations and exercises</li>
                  <li>PDF copy of the materials is available</li>
                  <li>Ask questions at any time</li>
                  <ul><li>Use the chat window</li></ul>
                </ul>
              </section>-->
 <!--IF James IS TEACHING-->
           
              
					<h3>Trainer Intro</h3>

                    <div style="float:left;width:50%;" class="centered">
                      <p>
                      <strong>James Tacker</strong>
                      <p>Technology Consultant & Content Developer</p>
                      <p>Previous Training Work:</p>
                      <ul>
                      	<li>NGINX</li>
                      	<li>New Relic</li>
                      	<li>Salesforce</li>
                      	<li>Atlassian</li>
                      </ul>
                      <p><a href="mailto:james.tacker@servicerocket.com">james.tacker@servicerocket.com</a></p>

					  </p>
                    </div>

                    <div style="float:right;width:40%;padding-right:0px;">
                      <img src="assets/images/Picture1.png" style="border:0;background:none; left:0; top:0;">
                    </div>
				</section>

	      <section>
		<h3>Prerequisites/Expectations</h3>
		<ul>
		  <li>Experience with scripting</li>
		  <li>Some familiarity with Java</li>
		  <li>Some familiarity with Selenium</li>
		  <li>Selenium 101</li>
		  <li>Some knowledge of Continuous Integration and REST APIs</li>
		</ul>
	      </section>
	      
              <section>
                <h3>The Training Environment</h3>
		
                <ul>
                  <li>ReadyTech virtual machines</li>
                  <li>Eclipse</li>
		  <li>Java</li>
                  <li>Maven</li>
		  <li>Sauce Labs</li>
                </ul>
		
                <aside class="notes">
                  <p>So before we go into the different parts we need to incldue in a script, let's talk about our training environment.</p>
                  <p>First off, we'll be working in a VM provided by ReadyTech today. If you have any problems during the course of labs, I will be able to go into your instance and help you out. You can just notify me using the ReadyTech instance to tell me that you need help.</p>
                  <p>We're also going to be working in Eclipse today. In Eclipse, we have set up the scripts within a framework called TestNG, for Java, that allows us to run the scripts with all of the dependencies it needs very easily.</p>
                  <p>That within that framework, there is a library, or build tool, called Maven that we are using to grab our dependencies, bundle them together, and then run our script.</p>
                  <p>Normally, we would have to run a long command that looks like:</p>
                  <pre><code class="java" data-trim contenteditable>
                        javac -cp ".:./selenium-2.53.0/selenium-java-2.53.0.jar:./selenium-2.53.0/libs/*" SampleSauceTest.java
                        java -cp ".:./selenium-2.53.0/selenium-java-2.53.0.jar:./selenium-2.53.0/libs/*" SampleSauceTest
                  </code></pre>
                  <p>The first line compiles the code with all of the requisite libraries and jars it needs, and then the second line runs it.</p>
                  <p>Maven will do all of that for us, so we don't need to run an additional script to start the test script, or have to include the libraries manually in a command.</p>
                  <p>Throughout the course today, the way we will run our tests is by using the "Maven test" command, which should compile all of our resources and dependencies together, and run it for us.</p>
                  <p>Lastly, for those of you who may not have used Eclipse before, when you type in a line that does not have the right syntax, it will generally underline the offending line or part of the line that you need to fix, in red. If you simply hover or select that part of the line, Ecplise will give you suggestions on how to fix the problem.</p>
		  
                </aside>
              </section>

	      <section>
		<h3>Saucelabs.com Account</h3>
		<p>If you haven't do so already, please take the time to create a saucelabs.com account.</p>
		<p>If you had already made one in the past, and your free trial has run out, let me know!</p>
	      </section>
	      
	      <section>
		<h3>Accessing the ReadyTech Environment</h3>
		<ul>
		  <li>Check your email for a link to the environment and your access code.</li>
		  <ul><li>Look in spam!</li></ul>
		  <li>Enter your access code.</li>
		  <li>You will arrive in the <span style="color:rgb(87,193,232); display:inline;">Lobby</span> tab.</li>
		  <li>Access the environment by clicking on the <span style="color:rgb(87,193,232); display:inline;">Lab</span> tab.</li>
		  <li>Click on the Remote Desktop image. This will take to you to the remote desktop.</li>
		</ul>
	      </section>
	      
              <section>
                <h3>Agenda</h3>

                <div style="text-align:left;">
                    <img src="assets/images/agenda.png" style="border:none; background:none; width:80%">
                </div>
		
		<aside class="notes">
		</aside>
              </section>

		<section>
		  <h3>Sauce Labs</h3>
		  <p>Testing infrastructure in the cloud for web and mobile web applications.</p>
		  <ul>
		    <li>Web Automated Testing</li>
		    <li>Mobile Automated Testing</li>
		  </ul>
		  <aside class="notes">
		    <p>Sauce Labs supports Selenium and Appium, which are open source automated testing platforms for browser and mobile applications.</p>
		    <p>They offer testing infrastructure for rent in the cloud, which saves companies who are looking to streamline thier CI/CD process, both time and money.</p>
		  </aside>
		</section>
	      
<!--Adv. Scripts Module-->
              <section data-background="rgb(226, 35, 26)">
                <h2>Advanced Locators</h2>
              </section>

                <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
                    <li>Understand optimal locator strategy</li>
                    <li>Write a script using locator strategy</li>
                    <li>Understand and use the Selenium Actions class</li>
		  </ul>
                  <aside class="notes"></aside>
                </section>

		<section>
		  <h3>Selenium Review</h3>
		  <div style="text-align:center;">
                    <img src="assets/images/Gears.png" style="border:0; background:none; width:50%">
                  </div>
                  <aside class="notes">
                    <p>Time for a quick review of how Selenium works!</p>

                    <li>Selenium IDE: A firefox add-on that can create a script from a manual test, allow you to do maual testing, and debug your own test scripts.</li>
                    <li>Selenium Client API: What we will be using today, as part of the Selenium Webdriver. It allows tests to be written in a variety of programming languages, so it enables us to write our tests in Java. These are the language specific bindings.</li>
                    <li>Selenium WebDriver: The client that accepts the commands via the API or in the Selenium scripting language and sends those commands to a browser.</li>
                    <li>Selenium Grid: This is the Selenium Server, which allows tests to to use web browsers on other machines. This is what Sauce Labs does for you, but on a very large scale and with a lot of options for machines and browsers - not restricted to just one version either.</li>
                  </aside>
		</section>

		<section>
		    <h3>Selenium Architecture</h3>
		    <!-- Left Column -->
		     <div style="float:left;width:45%;" class="centered">
		    
		    <div class="fragment" data-fragment-index="3" style="vertical-align:left; margin-left: auto; margin-right: auto;">
		      <img src="assets/images/webdriver.png" style="border:0; background:none; width:46%">
		    </div>
		    <div class="fragment" data-fragment-index="2" style="vertical-align:left; margin-left: auto; margin-right: auto;">
		      <img src="assets/images/atoms.png" style="border:0; background:none; width:38%">
		    </div>
		    <div class="fragment" data-fragment-index="1" style="vertical-align:left; margin-left: auto; margin-right: auto;">
		      <img src="assets/images/closure.png" style="border:0; background:none; width:40%">
		  </div>
		</div>
		<!--Right Column-->
		<div style="float:right;width:55%;padding-right:0px;">
		  <div class="fragment" data-fragment-index="3" style="vertical-align:right; margin-right: auto; margin-right: auto;"> <p><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">Selenium WebDriver:</span></pre>Fires events at OS level</p>
		  </div>
		  
		   <div class="fragment" data-fragment-index="2" style="vertical-align:right; margin-right: auto; margin-right: auto;"> <p><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">Atom Utility Library:</span></pre>Smallest units of actual browser automation</p>
		  </div>
		  
		   <div class="fragment" data-fragment-index="1" style="vertical-align:right; margin-right: auto; margin-right: auto;"> <p><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">Google Closure Library:</span></pre>Compilation layer used for modularization</p>
		  </div>
		</div>

		    <aside class="notes">
		      <ul>
		      	<li>Google’s Closure Library: Closure compiler used for modularization and atomization. It targets Javascript as the output language. The compilation can be simple to complex i.e. concatenation input files and printing them out, or dead code removal.</li>

<li>Atoms: Utility library used for atomizing the browser tasks i.e. getting value of an attribute, determining web element visibility, etc. Basically the smallest units of browser automation.</li>

<li>WebDriver: Adapter layers comprised of these atoms that meet API contracts. WebDriver fires events at OS level to emulate user so browser believes these to be native events, thus circumventing the security restrictions. Also because they are OS specific, getting one event to successfully work generally means testing them in other browsers is relatively easy.</li>
</ul>
		    </aside>
		</section>
		<section>
			<h3>Selenium WebDriver API</h3>
			<img src="assets/images/bindings_diagram.png" style="border:0; text-align:center; background:none;">
                    
                    <aside class="notes">
                      <p>Write code in language bindings, Selenium WebDriverAPI translates the code, sends those request to the corresponding web driver, driver sends response back to console.</p>
                    </aside>
                </section>

		
		<section>
		  <h3>Locators Review</h3>
		  <p style="text-align:center;">Locator Expressions are made in Key:Value pairs</p>
                  <pre><code class="java" data-trim contenteditable>
                          WebElement linkElement = driver.findElement(By.id("i am a link"));
                  </code></pre>
                  <aside class="notes">
		    <p>Before we get into the really advanced topics, this is just a reminder that locators are generally made by using key value pairs.</p>
		    <p>In our example here, the key is going to ID, and we are looking for the ID with the value "I am a link"</p>
                  </aside>
		</section>

		<section>
		  <h3>Locator Types</h3>
		  <p>Identify by:</p>
                  <div style="float:left;width:50%;" class="centered">
		    <ul>
		      <li>ID</li>
                      <li>Class Name</li>
                      <li>Tag Name</li>
                      <li>Name</li>
		    </ul>
		  </div>
                  <div style="float:right;width:50%;padding-right:0px;">
		    <ul>
		      <li>Link Text</li>
                      <li>Partial Linktext</li>
                      <li>CSS</li>
                      <li>XPATH</li>
		    </ul>
		  </div>
		  <aside class="notes">
		    <p>There are a decent amount of identifiers out there. Most of them are easy to use, but there are two that consistently are touted by people in the selenium community, CSS and XPATH.</p>
		    <p>There is a contention that Xpath is slower that CSS, but tests done by others, including dave haeffner of elemental selenium, has shown in a series of tests that there is no major difference. So at the end of the day, it comes down to how you can use it and how you can't, as well as preferrence.</p>
		  </aside>
		</section>
		
		<section>
		  <section>
		    <h3>XPATH vs CSS</h3>
		    <p>XPATH</p>
		    <ul>
		      <li>Can traverse the DOM from child to parent element. (Forwards and backwards)</li>
		    </ul>
		    <p>CSS</p>
		    <ul>
		      <li>Can only traverse the DOM from parent to child element.</li>
		      <li>Has a number of selectors for precise location</li>
		    </ul>
		    <aside class="notes">
		      <p></p>
		    </aside>
		  </section>

		  <section>
		    <h3>XPATH vs CSS - Which is faster?</h3>
		    <ul>
		      <p>The answer is - it depends!</p>
		      <li>XPATH tends to be faster on IE</li>
		      <li>CSS tends to be faster on all other browsers</li>
		      <p>Best choice is to use ID and Classes, which will be faster than traversing the DOM with CSS and XPATH selectors.</p>
		      <div style="text-align:center;"><small>Documentation: <a href="https://saucelabs.com/resources/articles/selenium-tips-css-selectors" target="_blank">CSS Selector Tips</a></small></div>
		      
		    </ul>
		    <aside class="notes">
		      <p>There has been a debate for quite a while now on the merits of CSS vs xpath. All the benchmark tests that I've seen show that CSS is generally faster. But faster only means a couple of microseconds on most browsers.</p>
		      <p>The hazard in using either one of these is that they generally depend on the hierarchy of the html on the page itself to locate elements. If your developers make a chnage in where an element is located, these locators can break pretty easily. Convince them to ID and name elements instead!</p>
		    </aside>
		</section>
			<section>
			<h3>XPATH vs CSS - Use Cases</h3>
			<ul>
				<li>Dynamic IDs</li>
				<li>Tabular Data</li>
				<li>Flexibility</li>
			</ul>
			<aside class="notes">
				<p>The primary use cases for using CSS Selectors and by extension, XPath, are if you have IDs but due to regression testing, or dynamic behavior, or if there is a grouping of elements with the same ID, then selectors or XPath would be the way to go.</p>
				<p>Other uses cases are if you have tabular data that is also dynamic or nested deep in the page, and you're trying to pull values from a cell and insert into an arithmitic expression.</p>
				<p>CSS and XPath give you the flexibility to travese the DOM more accurately but it's important to know some of the more advanced locators if we plan on utilizing them more efficiently. Modern web pages are becoming more style-centric so having that flexibility to combine multiple attributes makes CSS attractive to advanced users.</p>

			</aside>
		</section>
		</section>
		  <section>
		  	<section>
		  	<h3>Basic CSS Selectors</h3>
		  	<p>ID and Class</p>
                  <pre>
                    <code class="java" data-trim contenteditable>
#id
driver.findElement(By.cssSelector("#submit"));
#class
driver.findElement(By.cssSelector(".submit"));
                    </code>
                  </pre>
            <p>Child/Sub-Child</p>
                  <pre>
                    <code class="java" data-trim contenteditable>
                      driver.findElement(By.cssSelector("div a"))
                    </code>
                  </pre>
            
		  	<aside class="notes">
		  		<ul>
		  			<li><strong>ID</strong>Prefixing the hash symbol to a selector allows us to target by id, do not use these too liberally because they don't allow for re-use. Instead use a class or a tag name. Or if using selenium, why not just locate using the FindbyElement.id class?</li>
		  			<li><strong>Class</strong>the dot represents a class selector. The main difference between id and class is the with the class locator you can target multiple elements. So for example if you're styling a group of elements use a class. But if you're trying to find something deeply nested in page like a needle in a haystack ids might be the best bet.</li>
		  			<li><strong>Child or Sub-Child</strong> The white space indicates a child or a sub-child selector. Also known as a 'descendant' selector, this is one of the more common CSS selectors. Use this when you want to be more specific with your actions. For example if you need to access an anchor tag in a specific div rather than searching all divs.</li>
		  		</ul>
		  	</aside>
		</section>
		<section>
			<h3>Advanced CSS Selectors</h3>
			<p>Attribute</p>
                  <pre>
                    <code class="java" data-trim contenteditable>
                      driver.findElement(By.cssSelector("div[name='submit']"))
                    </code>
                  </pre>
            <p>Multiple Attributes</p>
                  <pre>
                    <code class="java" data-trim contenteditable>
                      driver.findElement(By.cssSelector("div[name='submit'] [data-type='button']"))
                    </code>
                  </pre>

                  <aside class="notes">
                  	<ul>
                  		<li><strong>Attributes</strong> The attributes selector allows us to target elements by specific attribute values by nesting that information in between a pair of brackets []. This is useful if you're trying to target or identify a specific styling.</li>
                  		<li><strong>Multiple Attributes</strong>You can also daisy chain the attributes by placing new [] with other attributes, as long as they're encased by quotations.</li>
                  	</ul>
                  </aside>
		</section>
		<section>
			<h3>Sub-String Matches</h3>
			<p>Contains</p>
                  <pre>
                    <code class="java" data-trim contenteditable>
                      driver.findElement(By.cssSelector("div[name*='submit_button']"))
                    </code>
                  </pre>
			<p>Starts with</p>
                  <pre>
                    <code class="java" data-trim contenteditable>
                      driver.findElement(By.cssSelector("div[name^='submit_']"))
                    </code>
                  </pre>
            <p>Ends with</p>
                  <pre>
                    <code class="java" data-trim contenteditable>
                      driver.findElement(By.cssSelector("div[name$='_button']"))
                    </code>
                  </pre>
			<aside class="notes">
				<ul>
					<li><strong>'Match a sub-string'</strong>Using an asterik along with and equal modifier will attempt to find an element attribute based on the text value</li>
					<li><strong>'Match a Prefix'</strong>The carrot symbol along with an equal modifier will attempt to find an element attribute that starts with whatever text characters you specific</li>
					<li><strong>'Match a Suffix'</strong>And finally, the Dollar sign along with the equal modifier will attempt to match the end of an element attribute text value</li>
				</ul>
			</aside>
	</section>
	<section>
		<h3>Other Locators</h3>
		<ul>
			<li>adjancent elements (~ or +)</li>
			<li>pseudo-classes</li>
			<ul>
				<li>:after || :before</li>
				<li>:contains</li>
				<li>:hover</li>
			</ul>
		</ul>
		<div style="text-align:center;"><small>Documentation: <a href="https://code.tutsplus.com/tutorials/the-30-css-selectors-you-must-memorize--net-16048" target="_blank">Pro CSS Tips</a></small></div>
		<aside class="notes">
			<ul>
				<li><strong>Adjacent Selectors</strong> are useful if you only want to target immediately after the specified element. The difference between the + and ~ symbol is that the tilde is less strict</li>
				<li><strong>Psuedo-Classes</strong> are interesting because they allow us to target elements based on unique behavoirs such as contains will check the inner text of an element and hover is classified as a user action psuedo-class which will allows us to make styling changes or locator commands based on whether a user is hovering over an element.</li>
			</ul>
			<p>For more information about the many many selectors that are available and perhaps ways to cleverly use them when you're finding elements, plese checkout the link below</p>
		</aside>
</section>
</section>
<section>
	<h3>XPath: Relative vs. Absolute</h3>
	<ul>
		<li>Absolute: starts from the root element of page or </li>
		<li>Relative: built around adjacent nodes in DOM</li>
		
	</ul
	
	<p><pre>
        <code class="css" data-trim contenteditable>
#Absolute
HTML/head/body/table/tr/td; 
#Relative
//table/tr/td; 
                    </code>
                  </pre></p>
<aside class="notes">
	<p><strong>Absolute:</strong> It starts from the root element within the web page or part of the page and goes to identify the target element. To use locators like the XPath is easy as you give the direct element path. But the XPath would break when the element structure changes.</p>
	<p><strong>Relative:</strong> The relative XPath are easy to manage as they are short and concise. It is also better than the previous XPath style as it may survive the changes in the Page HTML to a certain degree. Though, building a relative XPath is time-consuming and quite difficult as you need to check all the nodes to form the path. It does however, guarantee more accurate locators.</p>
</aside>
</section>

<section>
		  <h3>Locator Priority Recap</h3>
		  <ol>
		    <li>ID and/or Name</li>
		    <li>Classes</li>
		    <li>Tell Devs to create Id/Class</li>
		    <li>CSS Selectors</li>
		    <li>XPATH</li>
		  </ol>
		  
		  <aside class="notes">
		    <p>So what's the best way to actually write and identify locators on a page? Like with much of Selenium and testing in general, it depends on how your application or site is laid out, in the html and css.</p>
		    <p>Generally, lcoating elements through their specific name or id is going to be the fastest method. But that can be a fantasy as far as modern web applications go. Second, you'd try to use the classes and then CSS Selectors. And finally, you'd want to use the XPATH. The XPATH selector is generally the locator of last resort due to its brittleness and slow speed on some specific browsers. Otherwise CSS Selectors will generally work out fine. </p>
		  </aside>
		</section>
		
		<section data-state="lab">
		  <h3>Lab 1: Locators</h3>
		  <ol>
		    <li>Open Eclipse and navigate to <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">SampleLocatorTest.java</pre></li>
		    <li>Open Eclipse and replace <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">USERNAME =</pre> <pre style="display:inline; color:rgb(0,0,0);"><span style="font-size: 30px;">"SAUCE USERNAME"</pre> and <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">ACCESS_KEY =</pre><pre style="display:inline; color:rgb(0,0,0);"><span style="font-size: 30px;"> "SAUCE ACCESS_KEY"</pre>, with your <a href="https://saucelabs.com">Saucelabs.com</a> account credentials</li>
		    <li>Ensure the test URL is <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">driver.get("http://the-internet.herokuapp.com/large")</pre></li>
		    <li>Uncomment the two ID and XPath locators: <pre style="display:inline; color:rgb(87,193,232);">WebElement tableID = driver.findElementById("");</pre>
<pre style="display:inline; color:rgb(87,193,232);">WebElement table50 = driver.findElementByXPath("");</pre><span style="font-size: 30px;"></li>
		    <li>Find a value in one of the table cells and write a CSS Locator to print out that value using: <pre style="display:inline; color:rgb(87,193,232);">System.out.println(someWebElement);</pre></li>
		  </ol>
		  <aside class ="notes">
		  	<p>So for this lab we're going to demonstrate the different types of locators we can use, talk about how they traverse the DOM given that there's a page with elements that are nested deeply within the page, and we will print out the results.</p>

		  	<p>First, we need to enter our Sauce Labs authentication details for the script, so go to your account details at saucelabs.com if you haven't already and copy that into the variablrs "YOUR_USERNAME" and "ACCESS_KEY"</p>

		  	<p>Then, we will open up http://the-internet.herokuapp.com/large and note the complicated nesting of each of these webelements. As you can see we have a very large table with deeply nested elements. There are many needle-in-haystacks as they're often referred to. If we want to traverse one way, i.e. down the page CSS Locators are recommended, if we need to locate an elment down the page, and then traverse back up the page, we will need Xpath</p>

		  	<p>So let's uncomment the two ID and Xpath locators for the table ID, in our script </p>
		  	<pre><code class="java" data-trim contenteditable>
WebElement tableID = driver.findElementById("large-table");
</code></pre>
			<p>Then we will choose 2 elements in the table, I'm going to choose some column in row 50-51, and write Xpath and CSS Locators for both</p>

<pre><code class="java" data-trim contenteditable>
WebElement table50 = driver.findElementByXPath("//*[@id=\"large-table\"]/tbody/tr[50]/td[20]");
WebElement table51 = driver.findElementByCssSelector("#large-table > tbody > tr.row-50 > td.column-19");
</code></pre>

			<p>Then we will print out the results</p>
<pre><code class="java" data-trim contenteditable>
System.out.println(tableID);
        System.out.println(table50);
        System.out.println(table51);
    </code></pre>

    <p>Now our CSS loctor is not very effecient because it's unecessarily calling the ID and the class. We could just get rid of everything up to tr.row, and rather than use a >, which represents a direct child, we could just use a descendant locator and have <pre><code class="java" data-trim contenteditable>("tr.row-50 td.column-19");</code></pre></p>

    <p>After we've optimized our CSS Selector, let's go ahead and assert the inner text of that particular cell just to make sure it's still grabbing the right value.</p>

    <pre><code class="java" data-trim contenteditable>
    	assertEquals(table51.gettext(), "50.19");</code></pre>

    	<p>Test in SauceLabs to make sure everything is working correctly</p>
</aside>

		</section>
		
		
		<!--Actions Module-->
              <section data-background="rgb(226, 35, 26)">
                <h2>Simulating Actions</h2>
              </section>
              
              <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
                    <li>Explore the Action Class</li>
                    <li>Understand when to use multiple actions vs. chained actions</li>
                    <li>Identify use cases for the JS Executor class</li>
		  </ul>
                  <aside class="notes"></aside>
                </section>
                <section>
		  <h3>Actions Review</h3>
                  <pre>
                    <code class="java" data-trim contenteditable style="text-align:center;">
                      driver.findElement(By.name("query")).sendKeys("actions");
                    </code>
                  </pre>
		  <aside class="notes">
		    <p>Actions work the same way that they always have. You locate an element, and then you can perform one of the standard clicks, submits, sendkeys on that located element. So with this example we're doing all of the actions in one go</p>
		  </aside>
		</section>

		<section>
		  <h3>Actions Class</h3>
		  <pre>
                    <code class="java" data-trim contenteditable style="text-align:center;">
		      Actions action = new Actions(driver);
		    </code>
		  </pre>
		  <ul>
		    <li>Limited for particular browser versions</li>
		    <li>Allows you to chain together actions</li>
		    <li>Provides additional directives for precise keyboard and mouse operations</li>
		  </ul>
		  <aside class="notes">
		    <p>This is similar to TouchActions class that is used in Appium test scripts. In fact, TouchAction inherits from this class (touchaction is a subclass).</p>
		  </aside>
		</section>

		<section>
		  <h3>Chaining Actions</h3>
		  <pre>
                    <code class="java" data-trim contenteditable>
		      WebElement button = driver.findElement(By.id("button1"));
		      
Actions action = new Actions(driver);
		      
action.contextClick(button).build().perform();
		    </code>
		  </pre>
		  <p>Chain actions together to make a consolidated action object</p>
		  <aside class="notes">
		  	<p>So rather than executing the actions in one go, you can place the desirable actions in an actions, class which will allow you to not only chain them, but also re-use them throughout the script.</p>
		  </aside>
		</section>

		<section>
		  <h3>Keyboard Interactions</h3>
		  <p>The Keyboard interactions class is used by the Actions class but is unstable when used its own.</p>
		  <p>Some of the actions from the Keyboard interface:</p>
		  <ul>
		    <li><pre style="display:inline;">pressKey(keys)</pre></li>
		    <li><pre style="display:inline;">releaseKey(keys)</pre></li>
		    <li><pre style="display:inline;">sendKeys(keys)</pre></li>
		  </ul>
		  <aside class="notes">
		    <p>Press and release keys require variables that represent keys on the keyboard that are text. This means things like the TAB key, or escape. sendKeys can do it all, it's essentially a combined press and release keys.</p>
		  </aside>
		</section>

		<section>
		  <h3>Mouse Interactions</h3>
		  <p>The Mouse interactions class is used by the Actions class but is unstable when used its own.</p>
		  <p>Some of the actions from the Mouse interface:</p>
		  <ul>
		    <li><pre style="display:inline;">click(Coordinates xy)</pre></li>
		    <li><pre style="display:inline;">contextClick(Coordinates xy))</pre></li>
		    <li><pre style="display:inline;">doubleClick(Coordinates xy))</pre></li>
		    <li><pre style="display:inline;">mouseDown(Coordinates xy))</pre></li>
		    <li><pre style="display:inline;">mouseMove(Coordinates xy, x offset, y offset))</pre></li>
		    <li><pre style="display:inline;">mouseUp(Coordinates xy))</pre></li>
		  </ul>
		  <aside class="notes">
		    <p>The coordinates class consists of x and y locators for the current location of the mouse on the page. </p>
		  </aside>
		</section>
		
		<section>
		  <h3>Hover</h3>
		  <pre>
		    <code class="java" contenteditable data-trim>
		      WebElement hoverElement = driver.findElement(By.id("hoverElement"));
Actions builder = new Actions(driver);

builder.moveToElement(hoverElement).build().perform();
		    </code>
		  </pre>
		  <aside class="notes">
		    <p>One of the more advanced application interactions we get questions about revolve around hovers. Which we can see are not as complicated to write as they may sound.</p>
		    <p>A hover really just involves moving the mouse pointer to the element.</p>
		    <p><a href="http://the-internet.herokuapp.com/hovers">http://the-internet.herokuapp.com/hovers</a></p>
		  </aside>
		</section>

		<section>
		  <h3>Drag and Drop</h3>
		  <pre>
		    <code class="java" contenteditable data-trim>
		  Actions dragNDrop = new Actions(driver);
dragNDrop.dragAndDrop(elementA, elementB).perform();
		    </code>
		    </pre>
		  <aside class="notes">
		    <p>The Actions class also includes a directive to intiate a drag and drop. It's best however to define the elements in variables first based on their relative x, y coordinates, rather than explicitly hard-coding those coordinates in the dragandDrop action</p>
		  </aside>
		</section>

		<section>
		  <h3>Focus</h3>
		  <pre>
		    <code class="java" contenteditable data-trim>
		      new Actions(driver).moveToElement(element).perform();
		    </code>
		  </pre>
		  <aside class="notes">
		    <p>The best way to switch the focus between elements in a script is to use the moveToElement function. What we mean by focus is simply moving the mouse to a point or element and stopping. This is the best action to hover over an element or if you have a sequence of movements that need to be precise.</p>
		  </aside>
		</section>

		<section>
			<section>
		  <h3>Selenium JS Executor</h3>
		  <p>Executes JavaScript in the context of the currently selected frame or window. The script fragment provided will be executed as the body of an anonymous function.</p>
		  <pre>
		    <code class="java" contenteditable data-trim>
		      ((JavascriptExecutor) driver).executeScript("alert('hello world');");
		    </code>
		  </pre>

		  <aside class="notes">
		    <p>Need to cast the driver as a JavascriptExecutor first.</p>
		    <p>There is also the ability to run a script asynchronously</p>
		    <p>Execute an asynchronous piece of JavaScript in the context of the currently selected frame or window. Unlike executing synchronous JavaScript, scripts executed with this method must explicitly signal they are finished by invoking the provided callback. This callback is always injected into the executed function as the last argument.</p>
		  </aside>
		</section>
		<section>
			<h3>JS Executor Examples</h3>
			<p>JS Executor Click</p>
                  <pre>
                    <code class="java" data-trim contenteditable>
                      JavascriptExecutor js = ((JavascriptExecutor) driver);
                        js.executeScript("arguments[0].click();", element);
                    </code>
                  </pre>
            <p>Scroll a vertical page</p>
                  <pre>
                    <code class="java" data-trim contenteditable>
                      JavascriptExecutor js = (JavascriptExecutor)driver;
  			js.executeScript("window.scrollBy(0,50)");
                    </code>
                  </pre>
                  <div style="text-align:center;"><small>Documentation: <a href="http://www.ufthelp.com/2014/11/what-is-javascriptexecutor-in-selenium.html" target="_blank">JS Executor Examples</a></small></div>
                  <div style="text-align:center;"><small>Documentation: <a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/JavascriptExecutor.html" target="_blank">Class Reference</a></small></div>
                  <aside class="notes">These are some common examples of how to use the JS Executor, provided by the JS Executor documentation page which is listed for you at the bottom. However the most common use case for using a JS Executor is to simulate and/or handle AJAX calls. So for more information on that topic because it's a bit out of scope for this course, click the link below for more info and examples</aside>
		</section>
	</section>
		
		<section>
		  <h3>Accessibility Testing</h3>
		  <p>Testing your website's accessibility for people with disabilities</p>
		  <ul>
		    <li>Physical - Using tabs to go from element to element</li>
		    <li>Hearing - Using alt text in images, putting page titles in headers</li>
		    <li>Vision - Color contrast for text on the page</li>
		  </ul>
		  <p style="text-align:center;"><a href="http://sauceio.com/index.php/2015/12/accessibility-ax-testing-in-the-devops-chain/">Blog: Accessibility (AX) Testing in the DevOps Chain</a></p>
		  <aside class="notes">
		    <p>Accessibility testing can be pretty important for your application. Accessible websites/applications have a number of features that make it easier for people with disabilities to interact with the application.</p>
		    <p></p>
		  </aside>
		</section>
	
		<section data-state="lab">
		  <h3>Lab 2: Action Class</h3>
		  <p>In this lab we will explore the action class</p>
		  <ol>
		    
		    <li>In <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">SampleLocatorTest.java</pre>, uncomment the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">'Lab2'</pre> section</li>
		    <li>Locate the first image in this <a href="http://the-internet.herokuapp.com/hovers">URL,</a> via a CSS Selector</li>
		    <li>Create a hover <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">Action</pre> with <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">moveTo()</pre></li>
		    <li>Create a second <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">Action</pre> that uses <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">click()</pre></li>
		    <li>Click on the appropriate figcaption using a CSS selector and a <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">WebDriverWait</pre></li>
		    <li>Run a Maven test and check the results in <a href="https://saucelabs.com">Saucelabs.com</a></li>
		  </ol>
		<aside class="notes">
		<p>In this lab we're going to hover over an image, wait for a figcaption to display a hyper link, and click on the hyperlink. So let's open up the URL and demo what we're trying to achieve</p>

		<p>Comment out our existing locators for lab 1, and scroll down to the section entitled lab 2, let's go ahead and uncomment the lab 2 section</p>

		<p>So first thing we need to do is locate the CSS selector of our ficaption and create a new WebElement</p>

		<pre><code class="java" contenteditable data-trim>
WebElement fig = driver.findElementByCssSelector("#content > div > div:nth-child(3) > div > a");
</code></pre>

		<p>Then, we need to set our action and our wait near the top</p>
		<pre><code class="java" contenteditable data-trim>
//set Actions
        Actions action = new Actions(driver);

        //set waits
        WebDriverWait wait = new WebDriverWait(driver, 5);
</code></pre>

		<p>Next, we will call our action and perform them together</p>
		<pre><code class="java" contenteditable data-trim>
action.moveToElement(hover1).moveToElement(fig).click().build().perform();
</code></pre>

		<p>When, we run our test what happens? It should've failed, because of three things, we're trying to locate an element that hasn't rendering on the page yet, once we move to the element it disappears because it only appears during a hover, and we're also trying click within an action chain, which is not best practices when interacting with Web elements. So we need to do two things:</p>
		<ul>
			<li>Create an explicit wait for our figcaption to render</li>
			<li>Define that new web element with our wait in mind</li>
		</ul>

		<p>So the correct syntax is:</p>
		<pre><code class="java" contenteditable data-trim>
//Lab 2
driver.get("http://the-internet.herokuapp.com/hovers");

//set Actions
Actions action = new Actions(driver);

//set waits
WebDriverWait wait = new WebDriverWait(driver, 5);

//Call actions
//Actions class doesn't work with all browsers, works with chrome
WebElement hover1 = driver.findElementByCssSelector("#content > div > div:nth-child(3) > img");
action.moveToElement(hover1).build().perform();
WebElement fig = wait.until(ExpectedConditions.visibilityOfElementLocated(By.cssSelector("#content > div > div:nth-child(3) > div > a")));
fig.click();

        //Use sleep to view the "Not Found" page
        //Thread.sleep(2000);


        driver.quit();

	}
</code></pre>
<p>We can use a Thread.sleep at the end of the script if we want to see the results in or video capture log in SauceLabs.com, but using a Thread is bad practice when you're administering a heavy load of cross-browser testing.</p>
</aside>
		</section>

		
	      <!--Adv. Application Interactions Module-->
                <section data-background="rgb(226, 35, 26)">
		  <h2>Advanced Application Interaction</h2>
		</section>

                <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
                    <li>Perform advanced interactions on a page, beyond a simple click</li>
                  </ul>
                </section>

		<section>
			<section>
				<h3>Authentication</h3>
				<ul>
					<li>Different Browsers handle auth differently</li>
					<li>Most cases a base url will suffice</li>
					<li>If using self-signed certs, can click override link</li>
				</ul>
					<pre><code class="java" data-trim contenteditable>
					driver.navigate().to("javascript:document.getElementById('overridelink').click()");
}
</code></pre>
<aside class="notes">It's important to note here that depending on the browser you're dealing with, the behavior for authentication can be unpredicatble. For example, if you're trying to test basic auth by Safari, it's not fully supported. So even if you pass authentication details in the header of your request, safari by default, and also based on the browser preferences, will throw an alert message that warns the user of unsafe, or fraudulant websites. There are two ways to circumvent this: either you add what's called a 'prerun' executable that will force the browser to behave a certain way before the test runs, or you use this line of code here in an attempt to step through the warning message. Of course this requires you to understand how the alert message instanitates, and also have knowledge of it's ID, Xpath, and/or CSS locator.</aside>
			</section>
			<section>
		  <h3>Basic Authentication</h3>
		  <pre><code class="java" data-trim contenteditable>
		      driver.get("http://admin:admin@the-internet.herokuapp.com/basic_auth");
		  </code></pre>
		  <aside class="notes">
		    <p>There are a couple of different ways of authenticating, but doing it through the URL is usually the best way of going about it.</p>
		  </aside>
		</section>

		<section>
		  <h3>Cookie Insertion</h3>

		  <pre><code class="java" contenteditable data-trim>
		      Cookie cookie = new Cookie.Builder("name", "value")
		      .domain(".mydomain.com")
		      .expiresOn(new Date(2015, 10, 28))
		      .isHttpOnly(true)
		      .isSecure(false)
		      .path("/mypath")
		      .build();
		      
driver.manage().addCookie(ck);
		  </code></pre>

		  <pre><code class="java" contenteditable data-trim>
		      Cookie cookie = new Cookie("name", "value");
driver.manage().addCookie(cookie);
		  </code></pre>
		  
		  <div style="text-align:center;"><small>Documentation: <a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/Cookie.html" target="_blank">Cookies</a></small></div>
		   <div style="text-align:center;"><small>Documentation: <a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/WebDriver.Options.html" target="_blank">Webdriver Cookie Options</a></small></div>
		   <aside class="notes">So this is the cookie builder sub-class in java, the links to the documentation are located at the bottom. Each language binding will have it's own version of this functionality, so check your language documentation for specific deals. The basic idea here is to create a cookie, assign an name and value, set the parameters such as: expiration date, the domain the cookie is set for, the path to your JSP or application that the cookie is set for, and whether or not the cookie can bypass authentication--which is indicated by the isSecure parameter.</aside>
		</section>
	</section>

		<section>
		  <section>
		    <h3>File Uploads</h3>
		    <pre><code class="java" data-trim contenteditable>
			//set-up
driver = new RemoteWebDriver(new URL(URL), caps);
driver.setFileDetector(new LocalFileDetector());
		      
...
		      
//test
WebElement fileInput = driver.findElement(By.id("file-upload"));
fileInput.sendKeys("/Absolute/Path/to/Image.png");
		    </code></pre>
		    <aside class="notes">The file upload capabilities of Selenium will allow to simulate a POST or PUT HTTP method, if you have such features enabled on your site under test. To enable it, you simplyl have to set a file detector, and then based on the upload method whether it's a button or link, you reference it as a WebElement</aside>
		  </section>

		  <section>
		    <h3>File Downloads</h3>
		    <p>File downloads are more complicated</p>
		   <ul> <li>How do you deal with the dialogue box?</li>
		    <li>How do you actually check the contents or interact with the file?</li>
		    </ul>

		    <aside class="notes">
		      <p>The easiest way to deal with the dialogue box is to simply change the profile settings on the Browser. This is most easily done with Firefox, but when you do this, it is hard to determine where you actually downloaded the file to, and verify it's content.</p>
		      <p>There are a couple of methods out there on the internet, that involve getting the results through a cookie, or some fancy finagliing.</p>
		      <p>The real question is what you are trying to do. If you just need to be able to click on a link that downloads a file, then that is pretty easy. It's verifying the contents that get a bit trickier. It's normally not worth doing that using selenium, but rather manually.</p>
		    </aside>
		  </section>
		</section>

		<section>
		  <h3>Alerts</h3>

		  <pre><code class="java" data-trim contenteditable>
		      WebDriverWait wait = new WebDriverWait(driver, 2);
wait.until(ExpectedConditions.alertIsPresent());
Alert alert = driver.switchTo().alert();
alert.accept();
		  </code></pre>
		  <div style="text-align:center;"><small>Documentation: <a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/Alert.html" target="_blank">Alerts</a></small></div>		  
		</section>

		<section>
		  <h3>Popups</h3>
		  <pre><code class="java" data-trim contenteditable>
		      String myWindowHandle = driver.getWindowHandles();

driver.switchTo().window(myWindowHandle);
		  </code></pre>

		  <aside class="notes">
		    <p>Hopefully you all know that alerts and pop-ups are not the same thing. Pop-ups are just other browser windows, and these can switched between easily with the switchTo() function.</p>
		    <p>getWindowHandles()grabs current open popups so you can switch between handles in the array, getWindowHandle only selects the main window</p>
		  </aside>
		</section>
		
		<!--<section>-->
		<section data-state="lab">
		  <h3>Lab 3: Cookie Insertion</h3>
		  <ol>
		    <li>Open BasicAuthTest.java</pre></li>
		    <li>Uncomment the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">myCookie()</pre> Cookie builder</li>
		    <li>Try and set the cookie to bypass Authentication at: <a href="http://the-internet.herokuapp.com/basic_auth" target="_blank">"http://the-internet.herokuapp.com/basic_auth"</a></li>
		<li>Run <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">myCookie()</pre> in the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">@Test</pre> location</li>
		<li>If the cookie is unsuccessful, try appending <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">(admin:admin@)</pre> at the beginning of the URL</li>
		    <li>Set and print existing cookies using:</li>
		    <pre><code class="java" data-trim contenteditable>Set&#60;Cookie&#62; allCookies = driver.manage().getCookies(); 
	for (Cookie loadedCookie : allCookies) {
		System.out.println(String.format("%s -> %s", 
		loadedCookie.getName(), loadedCookie.getValue()));
	}</code></pre>
		  </ol>
		  <aside class="notes">
		  	<p>So this lab is a bit exeperimental, and what I mean by that is that it's not always successful depending on what your origin IP and whatever corporate firewall rules you have. Having said that we should be able to predict the behaviors because we're all using remote environments.</p>

		  	<p>First off: we ened to uncomment our public cookie builder so we can create a cookie</p>
		  	<p>Go ahead and add whatever parameters you wish, and then in the @Test method, we're going to call this cookieBuilder so we can set the cookie</p>

		  	<p>(do the first steps of the lab)</p>

		  	<p>Now in this particular script it's going to fail because of one reason, we have to wait for the entire page to load before a cookie can be added, and because the page isn't loading due to the basic auth window this approach won't work</p>
		  </aside>
		</section>

		<!-- <section data-state="lab">
		  <h3>Lab 3.5: Alert Messages</h3>
		  <ol>
		    <li>Use the switchTo() function to alternate between windows</li>
		    <li>Click the 'Ok' prompt in the alert message</li>
		  </ol>
		</section>
	</section> -->
		
<!--Waits Module-->
		<section data-background="rgb(226, 35, 26)">
		  <h2>Advanced Waits</h2>
		</section>

		<section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
                    <li>Understand the different kinds of waits and when to use them</li>
		  </ul>
                  <aside class="notes"></aside>
                </section>
		
              <section>
                  <h3>Explicit and Implicit Waits</h3>

                  <p>Implicit Waits</p>
                  <pre>
                    <code data-trim contenteditable class="java">
                      driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
                    </code>
                  </pre>

                  <p>Explicit Waits</p>
                  <div style="width:101%;">
                    <pre><code class="java" data-trim contenteditable>
                        import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
WebDriverWait wait = new WebDriverWait(driver, 10);
WebElement messageElement = wait.until(
                            ExpectedConditions.presenceOfElementLocated(
                            By.id("loginResponse")));
                    </code></pre>
                  </div>

                  <aside class="notes">
                    <p>There are many situations in which your test script may run ahead of the website or application you're testing, resulting in timeouts and a failing test. For example, you may have a dynamic content element that, after a user clicks on it, a loading appears for five seconds. If your script isn't written in such a way as to account for that five second load time, it may fail because the next interactive element isn't available yet. The general recommended solution for this is to use explicit waits.</p>

		    <p><mark>Why you may not want to use implicit waits w/ Fluent/explicit waits</mark>: Once you set implicit waiting, you cannot use explicit- or fluent wait until you reset the implicit waiting again. This means that ExpectedConditions, which contain driver.findElement calls will not work as expected with implicit wait! You'll often encounter cases where you want to check for an element or its non-existence instantly - but you can't do that either.</p>
		  </aside>
              </section>

	      <section>
	      	<section>
		<h3>Fluent Waits</h3>
		<pre><code class="java" contenteditable data-trim>
		    Wait fluentWait = new FluentWait(driver)
                  .withTimeout(30, SECONDS)
                  .pollingEvery(5, SECONDS)
                  .ignoring(NoSuchElementException.class);

WebElement foo = fluentWait.until(new Function() {
    public WebElement apply(WebDriver driver) {
        return driver.findElement(By.id("foo"));
    }
});
		</code></pre>
		<aside class="notes">
		  <p>Fluent waits allow you to set a timeframe to for your wait, and then create a polling event to test that element. So for this example we have a timeframe of 30 seconds, and Selenium will only test for changes every 5 seconds within that 30. </p>
		   <p>Each fluent wait instance defines the max time to wait for a condition, the polling interval, and optional ignore parameters. The best use case for using a fluent wait is if you have ajax application where certain web elements will appear for 1 second one time, and other times may take minutes to load. Another use case is to detect changes in properties of an element on a page like color, or value.</p>
		  <p>However, if you are just waiting for the object to render or load, then an implicit or explicit wait will be a better solution.</p>
		  <p>Once you've set the fluent wait parameters, you need to apply it to a local method to check for the condition.</p> 
		  <p> The polling continues until there is a timeout based on 30 seconds (which is check against real time), or the condition becomes true</p>

		  <p>This process will recur until either the timeout expires or the condition becomes true.</p>

		  <p>After the timeout expires, the start time is checked against the current time. If the difference of the wait start time and the current time is less than the time set in <withTimeout(30, SECONDS)> method, then Step-2 will need to repeat.</p>
		  <p>handy Link: <a href="http://www.techbeamers.com/webdriver-fluent-wait-command-examples/" target="_blank"></a></p>
		</aside>
	      </section>
	      <section>
	      	<h3>Fluent Wait Methods</h3>
	      	<div class="fragment" data-fragment-index="1" style="vertical-align:left; margin-left: auto; margin-right: auto;"><p><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">Function()</pre>: interface requiring a class</p></div>
	      	<ul>
	      		<div class="fragment" data-fragment-index="2" style="vertical-align:left; margin-left: auto; margin-right: auto;"><li><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">apply(F from)</pre></li></div>
	      		<div class="fragment" data-fragment-index="3" style="vertical-align:left; margin-left: auto; margin-right: auto;"><li><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">equals(Object obj)</pre</li></div>
	      	</ul>
	      	<div class="fragment" data-fragment-index="4" style="vertical-align:left; margin-left: auto; margin-right: auto;"><p><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">Predicate()</pre>: expects a boolean expression</p></div>
	      	<aside class="notes">
	      		<p>So sometimes we might need more than what is present in ExpectedConditions. If you pay close attention to the .until() in the fluent wait method you will realize that is an overloaded function that can take two types of parameters</p>
				<ul>
					<li>A Function is a general interface which requires the class to define any parameterized methods. Here we can set an apply(F from) or a equals(Object obj). It's important to set the the signature of the apply method. This Method for example can accept a WebDriver as the input argument and perhaps return a Boolean, Integer, or String value. Then using the equals method we can check CSS or element values and return the value.</li>
					<li>A predicate is similar to a function. But it always returns a Boolean expression. So if you want to check the value of a dynamically chainging object and set it to a true or false statement, which is more pratical for your assertions, then use a predicate</li>

				</ul>
	      	</aside>
	      </section>
	  </section>
<section data-state="lab">
		<h3>Lab 4: Explicit Waits</h3>
		<ol>
			<li>Open <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">SampleWaitTest.java</pre></li>
			<li>Create a <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">click()</pre> for the <a href="http://the-internet.herokuapp.com/dynamic_loading" target="_blank">loading page</a> URL</li>
			<li>Create a <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">click()</pre> for the 'Start' button</li>
			<li>Use a <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">wait</pre> to <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">assert</pre> the value of the inner text</li>
		</ol>
	<aside class="notes"></aside>
	</section>
	      <section data-state="lab">
		<h3>Lab 4.5: Fluent Waits</h3>
		<ol>
			<li>Open <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">SampleFluentWait.java</pre></li>
			<li>Uncomment <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">driver.get("");</pre> in the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">@Test</pre> section</li>
			<li>Uncomment the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">changingColor()</pre> fluent wait</li>
			<li>Set a <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">Predicate</pre> to check <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">rbg</pre> values of the 'dynamic_color' element</li>
			<li>Run the test and check the results in <a href="https://saucelabs.com">Saucelabs.com</a></li>
		</ol>
		<aside class="notes">
			<p>The example html page has text highlighting, as well as dynamic text. Create a fluent wait that will detect the following changes on the page i.e. color of text</p>
			<p></p>
			

<p>Note: make sure to change desired caps if you're testing on the saucelabs website</p>
			<p>Here is the fluent wait:</p>
			<pre><code class="java" contenteditable data-trim>
			FluentWait<WebDriver> wait = new FluentWait<WebDriver>(driver);
			wait.pollingEvery(250, TimeUnit.MILLISECONDS);
			wait.withTimeout(2, TimeUnit.SECONDS);
			wait.ignoring(NoSuchElementException.class);

		Function<WebDriver, Boolean> function = new Function<WebDriver, Boolean>() {
			public Boolean apply(WebDriver arg0) {
				WebElement element = arg0.findElement(By.id("dynamicColor"));
				String color = element.getCssValue("color");
				System.out.println("The button text has color :" + color);
				if (color.equals("rgba(255, 255, 0, 1)")) {
					return true;
				}
				return false;
			}
		};

	}
</code></pre>
		</aside>
	      </section>

	      <section>
	      	<h3>Abstracted Waits</h3>
	      	<p>Wrap wait in a method so that it is reusable</p>
	      	<pre><code class="java" contenteditable data-trim>
By element = By.id("myId");
	public WebElement clickableWait(By locator, Integer timeout) {
	timeout = timeout != null ? timeout : 10;
	WebDriverWait wait = new WebDriverWait(driver, timeout);
	return wait.until(ExpectedConditions.elementToBeClickable(locator));
}
	      	</pre></code>
	      </section>

<!--Testing Frameworks and Page Abstraction Module-->
                <section data-background="rgb(226, 35, 26)">
                  <h2>Page Objects and Abstraction</h2>
                </section>

                <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
                  <ul>
		    <li>Understand and use testing frameworks when writing test scripts</li>
                    <li>Leverage Frameworks to implement and work with the concept of page objectification</li>
                  </ul>
                  <aside class="notes"></aside>
                  
                  
              </aside>

                </section>
		
	        <section>
		  <h3>Testing Framework Review</h3>
                  <p></p>
                  <p>A test automation framework is a scaffold comprised of libraries, dependecies, drivers, and helper scripts that facilitate the execution of Selenium test scripts.</p>
                  <aside class="notes">
                    <p>Ok, what does that mean? It's essentially just a bunch of additional libraries we can use in conjunction with our script for several cases:</p>
                    <li>Record your data: Frameworks often have, or can have a way for you to output the results of your test scripts for you, rather than writing them by hand</li>
                    <li>Talk to external applications: you can include external libraries in your framework to talk to and send results to places like Sauce Labs</li>

                  </aside>
                </section>

                <section>
                  <h3>Popular Frameworks</h3>

                  <div style="float:left;width:50%;" class="centered">
                    <p><strong>Java:</strong></p>
                    <li>TestNG</li>
                    <li>JUnit</li>

                    <p><strong>Ruby:</strong></p>
                    <li>RSpec</li>
                    <li>Cucumber</li>
                    <p>
                  </p>
                  </div>

                  <div style="float:right;width:50%;padding-right:0px;">
                    <p><strong>Python:</strong></p>
                    <li>Robot</li>
                    <li>UnitTest</li>

                    <p><strong>JavaScript:</strong></p>
                    <li>Protractor</li>
                    <li>Nightwatch</li>
					<p>
                  </p>
                  </div>


                  <div style="text-align:center;"><small>Examples: <a href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/Cookie.html" target="_blank">Sauce Labs Sample Test Frameworks</a></small></div>

                  <aside class="notes">

                    <p>JavaScript:</p>
                    <li>Mocha</li>
                    <li>Karma</li>
                    <li>Jasmine</li>

                    <p>PHP:</p>
                    <li>PHPUnit</li>
                    <li>Sausage</li>
                    <li>Codeception</li>

                    <p>C#:</p>
                    <li>NUnit</li>
                    <li>MSTest</li>

                    <p>Perl:</p>
                    <li>TestMore</li>

                    <p>There are quite a few different frameworks out there. Sauce Labs has a github page with examples of scripts written using all of these frameworks.</p>

                  </aside>
                </section>

		<section>
		  <h3>TestNG</h3>
		  <ul>
		    <li>Inspired by JUnit and NUnit</li>
		    <li>Aims to cover wider range of types of testing</li>
		  </ul>
                  <aside class="notes">
		    <p>The testing framework that we are using today is TestNG. One big benefit of using a testing framework are the annotations, the @x that you see scattered through testing scripts. These help faciliate the design and build of a testing suite, allowing you designate particular functions as set-up, teardown, or actual tests. This makes it very easy to organize your code and tests, which makes maintaining them much less of a hassle. It also automates a lot of the ordering and funcion calls that you would have to make explicitly without the annotations.</p>
		  </aside>
		</section>

		<section>
		  <h3>Annotations</h3>
		  <div style="width:101%;">
		  <ul>
		    <li><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size:30px;">@Test</span></pre> - Marks a class or a method as part of the test</li>
		    <li><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size:30px;">@BeforeSuite</span></pre> - The annotated method will be run before all tests in this suite have run. </li>
		    <li><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size:30px;">@AfterTest</span></pre> - The annotated method will be run after all the test methods belonging to the classes inside the <test> tag have run</li>
		  </ul>
		  </div>
		  <br></br>
		  <div style="text-align:center;"><small>Documentation: <a href="http://testng.org/doc/documentation-main.html" target="_blank">TestNG Annotations</a></small></div>
		  <aside class="notes">
		    <p></p>
		  </aside>
		</section>
				<section>
		  <h3>Converting a Simple Script</h3>
		  <ol>
		    <li>Open basic scripts</li>
		    <li>Identify code that fits into at least 3 different sections</li>
		    <ul>
		      <li>Set-up</li>
		      <li>Test(s)</li>
		      <li>Teardown</li>
		    </ul>
		    <li>Separate the different parts into functions with the appropriate annotations</li>
		    <li>Analyze script for any repetitive identifications or actions and store values/actions in variables</li>
		  </ol>
		  <aside class="java">
		    <p></p>
		  </aside>
		</section>

		<section>
		  <section>
		    <h3>Example Script</h3>
		    <p>Parts of a complete test framework abstracted script</p>
		    <div style="text-align:center;"><img style="width:75%;" src="assets/images/pre-abstract.png"></img></div>
		  </section>
		  
		  <section>
		    <h3>Abstracted Script</h3>
		    <p>Parts of a complete test framework abstracted script</p>
		    <div style="text-align:center;"><img style="width:73%;" src="assets/images/after-abstract.png"></img></div>
		  </section>
		  
		  <section>
		    <h3>Abstraction Example 1</h3>
		    <p>Before:</p>
		    <pre><code class="java" data-trim contenteditable>
			driver.findElement(By.xpath("//div[2]/div/div/div/button")).click();
...
driver.findElement(By.xpath("//div[2]/div/div/div/button")).click();
		    </code></pre>
		    <p>After:</p>
		    <pre style="width:101%;"><code class="java" data-trim contenteditable>
			WebElement button = driver.findElement(By.xpath("//div[2]/div/div/div/button"));
button.click();
...
button.click();
		    </code></pre>
		    
		  </section>
		
		  <section>
		    <h3>Abstraction Example 2</h3>
		    <p>Before:</p>
		    <pre><code class="java" data-trim contenteditable>
		      WebElement hoverElement = driver.findElement(By.id("button"));
Actions builder = new Actions(driver);

builder.moveToElement(hoverElement).build().perform();
		    </code></pre>
		  
		    <p>After:</p>
		  <pre style="width:94%;"><code class="java" data-trim contenteditable>
		      WebElement hoverElement = driver.findElement(By.id("btn1"));
Action hoverBtn1 = new Actions(driver).moveToElement(hoverElement).build();
			 
hoverBtn1.perform();
		  </code></pre>
		</section>
		   </section>
		<section>
			<section>
                  <h3>Object Oriented Testing</h3>
                  <p>Page Objects</p>
                  <ul>
                    <li>Code reuse across tests; reuse common element interactions</li>
                    <li>Abstraction: With product change, only change one piece of code</li>
                  </ul>
                  <aside class="notes">
                    <p>
                      Sometimes we interact with particular elements in our application repeatedly. The nature of applications is that they change over time as well. Instead of writing the same code for the same interacctions, we can add a level of abstraction with page objects.
                    </p>
		    <p>Moving from the explicit to the abstract in order to make test maintentance easier</p>
		  </aside>
		</section>
		<section>
			<h3>Page Abstraction Steps</h3>
			<ol>
				<li>Create a <pre style="display:inline; color:red;"><span style="font-size:30px;">TestBase</pre> class</li>
				<li>Create a <pre style="display:inline; color:red;"><span style="font-size:30px;">PageBase</pre> class</li>
				<li>Abstract tests/tasks into <pre style="display:inline; color:red;"><span style="font-size:30px;">TestBase</pre> class</li>
				<li>Abstract page interactions into <pre style="display:inline; color:red;"><span style="font-size:30px;">PageBase</pre> class</li>
				<li>1 page object per page of site or app</li>
				<li>Page objects extend <pre style="display:inline; color:red;"><span style="font-size:30px;">PageBase</pre> class, <pre style="display:inline; color:red;"><span style="font-size:30px;">TestBase</pre> class instantiates page object</li>
			</ol>
		</section>

		<section>
				<h3>POM Example</h3>
				<p>Before Abstracted:
					<pre><code class="java" contenteditable data-trim>
public class MyTestClass{
	@Test
	public void main(){
		WebDriver driver = new WebDriver();
		driver.get("http://the-internet.herokuapp.com/checkboxes");	
		//Find and click checkbox 1 element
		driver.findElement(By.xpath("//*[@id=\"checkboxes\"]/input[1]")).click();
		//Find and click checkbox 2 element
		driver.findElement(By.xpath("//*[@id=\"checkboxes\"]/input[2]")).click();
		//get page title from current WebDriver
		String pageTitle = ((WebDriver) driver).getTitle();
		//Send Assert
		AssertJUnit.assertEquals(pageTitle, "The Internet");
		}
	}
}
	</pre></code></p>
	<aside class="notes">
		<h3>Advantages</h3>
		<ol>
			<li>With the Page Object Pattern we can separate the page operations, action flows, and UI tasks from the actual test execution and task verification. This concept makes our code cleaner and easy to understand.</li>
			<li>Second benefit of POM is that the object repository is independent of testcases, so we can use the same object repository for a different purpose with different tools. For example, we can integrate POM with TestNG/JUnit for functional testing and at the same time with JBehave/Cucumber for acceptance testing.</li>
			<li>Code becomes more atomic and optimized because of the reusable page methods in the POM classes. Which is one of the coure tenets of SauceLabs best practices</li>
			<li>Methods get more realistic names which can be easily mapped with the operation happening in UI. For example, if after clicking on a page UI button we land on the home page, the method name fot the button could be called'gotoHomePage()'.</li>
		</ol>
		<h3>How to Implement</h3>
		<p>Move all Web Elements that deal with the automation, and all methods that operate on these web wlements into a class file. Task and test verification should be separate as part of Test methods, so basically your remote authentication, desired capabilities, and asserts.</p>
</section>
<section>
	<h3>POM Example</h3>
				<p>After Abstracted:
					<pre><code class="java" contenteditable data-trim>
package pages;

public class MyPageObject{
	WebDriver driver;
	By checkbox1 = By.xpath("//*[@id=\"checkboxes\"]/input[1]");
	By checkbox2 = By.xpath("//*[@id=\"checkboxes\"]/input[2]");
	
	public WebDriver getWebDriver(){
		return driver.get("http://the-internet.herokuapp.com/checkboxes");
	}
	public void getCheckbox1(){
		driver.findElement(checkbox1);
	}
	public void getCheckbox2(){
		driver.findElement(checkbox2);
	}
	public String getPageTitle(){
		return driver.getTitle();
	}
	
}
	</pre></code></p>
	<div style="text-align:center;"><small>Documentation: <a href="https://raw.githubusercontent.com/wiki/SeleniumHQ/selenium/PageObjects.md" target="_blank">Page Object Model</a></small></div>
	<aside class="notes">
		<p>So as you can see here we have our operational commands of selenium separated out into separate methods that have logical names.</p>
	</aside>
</section>
<section>
	<h3>Instantiate the Page</h3>
		<p>To utilize the page object we must instantiate it</p>
		<p>The Test Page:
			<pre><code class="java" contenteditable data-trim>
import pages.MyPageObject;


public class MyTestCase extends MyPageObject {
	WebDriver driver;
	DesiredCapabilities caps;
	public String USERNAME = "your username";
	public String ACCESS_KEY = "your access key";

	public static MyPageObject getPage(WebDriver driver) {
		return PageFactory.initElements(driver, MyPageObject.class);
	}

	@BeforeMethod
	public void setup(){
		caps = new DesiredCapabilities();
		caps.setCapability("platform", "Windows 10");
		caps.setCapability("browserName", "chrome");
		caps.setCapability("version", "52.0");
	}

	@Test
	public void checkBoxTest() {
		driver = this.getWebDriver(caps);

		driver.getCheckbox1().click();
		driver.getCheckbox2().click();

	AssertJUnit.assertEquals(driver.getPageTitle(), "The Internet");
	}

	@AfterMethod
	public void teardown(ITestResult testResult) {

    		driver.quit();
    		SauceREST restAPI = new SauceREST(USERNAME, ACCESS_KEY);
    		if (testResult.isSuccess()) {
	        	restAPI.jobPassed(id);
	     	} else {
	        	restAPI.jobFailed(id);
	    	}
	}
}
	</pre></code></p>
	<aside class="notes">
		<p>We then import the test page. Extend its capabilities in the class. And then we can use a constructor that accepts a WebDriver as it's sole argument, then it retrieves the specific web driver that finds the elements. Then we can use that driver to run our page methods in a test method.</p>

		<p>Now some of you may have noticed this weid bit of syntax here with the constructor "Page Factory..." (go to next slide)</p>
	</aside>

</section>
<section>
	<h3>Page Factory</h3>
	<pre><code class="java" contenteditable data-trim>
package pages;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.PageFactory;


public class MyPageObject extends PageBase{
	@FindBy(id="unchecked_checkbox")
	private WebElement isUnchecked;

	@FindBy(id="checked_checkbox")
	private WebElement isChecked;

	public static MyPageObject getPage(WebDriver driver) {
		return PageFactory.initElements(driver, MyPageObject.class);
	}

...
	</pre></code>
	<div style="text-align:center;"><small>Documentation: <a href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory" target="_blank">Page Factory</a></small></div>
	<aside class="notes">
		So what the heck is a page factory? PageFactory is a support class for the Selenium 2 Page Objects patternPage Factory

Page Factory follows the concept of separation of Page Object repository and Test methods. With the help of the PageFactory class we can use annotations @FindBy to find WebElement rather than use driver.findElementby. Once the elements are located, we use the initElements method to initialize them in our scripts, after the page object is instantiated of course.

@FindBy annotation can accept attributes like tagName, partialLinkText, name, linkText, id, css, className, and xpath.
	</aside>
</section>
<section>
	<h3>Page Factory Explanation</h3>
	<ul>
	<li>Page Factory uses sensible defaults</li>
	<li>Page Factory uses same Driver that's passed through the constructor</li>
	<li>Page Factory can also intialize the elements via an already constructed object</p>
</ul>
	<pre><code class="java" contenteditable data-trim>
public class SearchMethod {
	private WebElement s;

	public void searchFor (String text) {
	//page is instantiated here
	s.sendKeys(text);
	s.submit();
	}
}
	</pre></code>
	<aside class="notes">
		<p>The name of the field in the Java class is assumed to be the "id" or "name" of the element on the HTML page. That is, in the example above, the line s.sendKeys(text) is equivalent to: driver.findElement(By.id("s")).sendKeys(text);</p>
		<p>In the example given, we rely on the PageFactory to instantiate the instance of the PageObject. It does this by first looking for a constructor that takes "WebDriver" as its sole argument (public SomePage(WebDriver driver) {). If this is not present, then the default constructor is called. Sometimes, however, the PageObject depends on more than just an instance of the WebDriver interface. Should this be the case, it is possible to get the PageFactory to initialise the elements of an already constructed object:</p>

		<p>MyPageObject page = new MyPageObject("title", driver);</p>
		<p>PageFactory.initElements(driver, page);</p>
	</aside>
</section>
<section>
	<h3>Ajax Locators</h3>
	<pre><code class="java" contenteditable data-trim>
		AjaxElementLocatorFactory = new AjaxElementLocatorFactory(driver, 100);
		PageFactory.initElements(factory, this);
	</pre></code>
	<aside class="notes">
		One of the key advantage of using Page Factory pattern is AjaxElementLocatorFactory Class.

It is working on lazy loading concept or more specifically, the SlowLoadableContent class runs internally with the AjaxElementLocatorFactory. What that means it that it will execute a timeout for a WebElement that will be assigned to the Object page class with the help of AjaxElementLocatorFactory. This reduces the reliance on WebDriver.Wait and is helpful when you're refractoring your code to page objects.

In this specific example, when an operation is performed on an element the wait for its visibility starts from that moment only. If the element is not found in the given time interval, test case execution will throw 'NoSuchElementException' exception.
	</aside>
</section>
</section>
<section>
	<h3>Page Object Summary</h3>
	<ul>
		<li>Public Methods = page "services"</li>
		<li>DO NOT expose internals</li>
		<li>Keep them small</li>
		<li>Different results for similar actions are modeled as different methods</li>
		<li>Assertions in Page Objects are bad</li>
	</ul>
	<aside class="notes">
<ul>
	<li>The public methods represent the services that the page offers. It's simplest to think of the methods on a Page Object as offering the "services" that a page offers rather than exposing the details and mechanics of the entire page.</li>
	<li>PageObjects can be thought of as facing in two directions simultaneously. Facing towards the developer of a test, they represent the **services** offered by a particular page. Facing away from the developer, they should be the only thing that has a deep knowledge of the structure of the HTML of a page (or part of a page)As an example, think of the inbox of any web-based email system. Amongst the services that it offers are typically the ability to compose a new email, to choose to read a single email, and to list the subject lines of the emails in the inbox. How these are implemented shouldn't matter to the test.</li>
	<li>That being said, it's best to keep each service in it's own method, and to keep it's logic small so that if something changes, for example a sign-on button moved into a different div, thus changing it's selector, you only have to edit that one page object method</li>
	<li>One consequence of this approach is that it may be necessary to model (for example) both a successful and unsuccessful login, or a click could have a different result depending on the state of the app. When this happens, it is common to have multiple methods on the PageObject</li>
	<li>And finally, the tests, not the PageObjects, should be responsible for making assertions about the state of a page. Reasons being it's annoying when you have a clever test method to handle your assertions but you have no idea what the test is asserting at a glance. So you then have to dive into the page object to find that buried assert. Assertions in page objects can cause more overhead because the page method is running everytime a test runs regardless of whether or not a particular test method needs that given assertions. This is why we abstract the asserts to the tests so that we can save minutes, if not hours to your overall test time. And finally the golden rule' one assertion per test. You don't want your tests failing for ambigious reasons because you buried them in a page object method</li>
</ul>
	</aside>
		</section>
		
		  
		  <section data-state="lab">
		  <h3>Lab 5: Page Objects and Abstraction</h3>
		  <ol>
		    <li>Open <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">MyPageObject.java</pre></li>
		    <li>Create a constructor with <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">PageFactory.initElements</pre> as the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">return</pre> value.</li>
		    <li>Uncomment/create public methods to capture the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">checkedCheckBox</pre> and <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">uncheckedCheckBox</pre> states</li>
		    <li>Open <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">MyTestCase.java</pre></li>
		    <li>Instantiate <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">MyPageObject</pre> class and test the check the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">uncheckedCheckBox</pre> state</li>
		    <li>Run the test and check the results in <a href="https://saucelabs.com">Saucelabs.com</a></li>
		  </ol>
		  <aside class ="notes">
<p>Sections that are missing in MyPageObject.java</p>
<pre><code class="java" data-trim contenteditable>
public static MyPageObject getPage(WebDriver driver) {
		return PageFactory.initElements(driver, MyPageObject.class);
	}

	public void checkUncheckedCheckBox() {
		setCheckBoxState(this.isUnchecked, true);
	}

	public boolean getUncheckedCheckBoxState() {
		return this.isUnchecked.isSelected();
	}

	public void uncheckCheckedCheckBox() {
		setCheckBoxState(this.isChecked, false);
	}

	public boolean getCheckedCheckBoxState() {
		return this.isChecked.isSelected();
	}
</code></pre>
<p>Sections missing in MyTestCase.java</p>
<pre><code class="java" data-trim contenteditable>
@Test
public void checkBoxTest() {
	 driver.get("https://saucelabs.com/test/guinea-pig");
	 MyPageObject page = MyPageObject.getPage(driver);
	 	page.checkUncheckedCheckBox();
	 	AssertJUnit.assertEquals(page.getUncheckedCheckBoxState(), true);
	 	driver.quit();
	}
</code></pre>
		  </aside>
		</section>
		
	      <!--Parallelization Module-->
                <section data-background="rgb(226, 35, 26)">
                  <h2>Test Parallelization</h2>
                </section>

                <section>
                  <h3>Module Objectives</h3>
                  <p>This module enables you to:</p>
		  <ul>
		    <li>Understand how to run your tests in parallel</li>
		    <li>Undestand best practices for writing test scripts that facilitate parallel testing.</li>
		  </ul>
                </section>

		<section>
		  <h3>What is Parallelization?</h3>
		  <p>Parallelization means starting and running your tests all at the same time, across all supported browsers and OS.</p>
		  
		  <aside class="notes">
                  </aside>
		</section>

		<section>
		  <section>
		    <h3>Parallelization Requirements</h3>

		    <ul>
		      <li>Framework</li>
		      <li>Small, Atomic, and Autonomous</li>
		      <li>Hardware</li>
		      <li>Network Resilience</li>
		    </ul>
		    
		    <aside class="notes">
		      <p>Framework helps to faciliate the different unit/feature tests, as well as the configuration of Browsers and OSs to test on.</p>
		      <p>Small, etc discussed on next slide</p>
		      <p>Hardware - either use Sauce Labs your own Selenium grid. Basically, you need to have the environments to test on</p>
		      <p>Network resilience means that you need to make sure that your application can handle the 100+ tests you're planning on hitting it with all at once. Make sure you have a proxy that can handle all the incoming requests.</p>
		    </aside>
		  </section>
		  
		  <section>
                     <h3>Small, Atomic, and Autonomous Testing</h3>

                      <div style="float:left;width:10%;padding-right:5px;padding-bottom:10px;"><img src="assets/images/icons.png" style="border:0; text-align:center; background:none;">
                  </div>
                     <div style="padding-top:10px;"><p><strong>Small:</strong> Tests should be short and succinct.</p>
                     <p><strong>Atomic:</strong> Tests should focus on testing a single feature.</p>
                     <p><strong>Autonomous:</strong> Tests should be independent of other tests.</p>
                   </div>
		    
                    <aside class="notes">
		      
                      <p>Short - If you have a test suite of 100 tests running concurrently on 100 VMs, then the time it will take to run the entire suite will be determined by the longest/slowest test case. Keeping your tests small ensures that your suite will run efficiently and provide you with results faster. </p>
                      <p>Atomic - The test makes clear exactly what it is that you're testing. If the test fails, then you should also have a very clear idea of what needs to be fixed. </p>
                      <p>Autonomous - Tests should not be dependent on the results of one test to run successfully. In addition, an autonomous test should use its own data to test against, and not create potential conflicts with other tests over the same data.  </p>
                    </aside>
                  </section>
		</section>

		<section>
		<section>
		  <h3>Using a Testing Framework for Parallelization</h3>
		  

		  <pre><code class="java" data-trim contenteditable>
		      @DataProvider(name = "hardCodedBrowsers", parallel = true)
public static Object[][] sauceBrowserDataProvider(Method testMethod) {
    return new Object[][]{
        new Object[]{"internet explorer", "11", "Windows 8.1"},
        new Object[]{"chrome", "41", "Windows XP"},
        new Object[]{"safari", "7", "OS X 10.9"},
        new Object[]{"firefox", "35", "Windows 7"},
    };
}
		  </code></pre>
		  <div style="text-align:center;"><p><pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">@DataProvider</span></pre> is a TestNG annotation.</p></div>

		  <aside class="notes">
		    <p>The data provider allows us to identify the browser, browser version and OS that we want to run our tests on. The testing framework really helps us out here with parallelization, as this tells the script to run it's defined tests all once on each of these different environments.</p>
		  </aside>
		  </section>
		
		<section>
		  <h3>@Test Parameters</h3>
		 
		 We need to make sure that our annotated tests refer back to the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">@DataProvider</span></pre> 
		 <pre style="text-align:center;"><code class="java" data-trim contenteditable>
		     @Test(dataProvider = "hardCodedBrowsers")
		 </code></pre>

		 <aside class="notes">
		   <p></p>
		 </aside>
		</section>
		</section>
		
		<section data-state="lab">
		  <h3>Lab 6: Parallelization Lab</h3>
		  <ol>
		    <li>Open <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">MyParrallelTestCase.java</pre></li>
		    <li>Uncomment the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">@DataProvider</pre> method</li>
		    <li>Reference the name of the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">@DataProvider</pre> in the <pre style="display:inline; color:rgb(87,193,232);"><span style="font-size: 30px;">@Test</pre> class method</li>
		    <li>Run the parallel tests and check the results in <a href="https://saucelabs.com">Saucelabs.com</a></li>
		  </ol>
		  <aside class="notes">
		  	<p>Sections missing in MyParallelTestCase.java</p>
		  	<pre><code class="java" data-trim contenteditable>
		  		@DataProvider(name = "hardCodedBrowsers", parallel = true )
	  public static Object[][] sauceBrowserDataProvider(Method testMethod) {
	      return new Object[][]{
	              new Object[]{"internet explorer", "11", "Windows 8.1"},
	              new Object[]{"chrome", "41", "Windows XP"},
	              new Object[]{"chrome", "54.0", "OS X 10.9"},
	              new Object[]{"firefox", "27.0", "Windows 10"},
	              new Object[]{"safari", "7.0", "OS X 10.9"},
	              }
	      	;
		}
</code></pre>
<p>and also missing in the same file</p>
<pre><code class="java" data-trim contenteditable>
@Test(dataProvider = "hardCodedBrowsers")
</code></pre>
		  </aside>
		</section>

		<section>
                  <h2>Additional Resources</h2>
                 </section>

		<section>
                  <h3>Further Information</h3>
                  <li><a href="http://www.seleniumhq.org/docs" target="_blank">SeleniumHQ: Documentation</a></li>
                  <li><a href="http://elementalselenium.com/" target="_blank">Dave Haeffner's Selenium Newsletter</a></li>
                  <li><a href="https://wiki.saucelabs.com/display/DOCS/The+Sauce+Labs+Cookbook+Home" target="_blank">Sauce Labs Documentation</a></li>
                  <li><a href="https://github.com/saucelabs-sample-scripts" target="_blank">Sauce Labs Sample Test Scripts</a></li>
                  <li><a href="https://github.com/saucelabs-sample-test-frameworks" target="_blank">Sauce Labs Sample Test Frameworks</a></li>
                  <aside class="notes"></aside>
                 </section>

                 <section>
                   <h3>Q&A</h3>
                   <li><a href="http://bit.ly/28NgER3" target="_blank">Survey!</a></li>
                   <li>Support: <a href="mailto:help@saucelabs.com" target="_top">help@saucelabs.com</a></li>
                   <aside class="notes"></aside>
                 </section>
		</div>
	  </div>
	  
      <script src="lib/js/jquery-2.2.4.min.js"></script>
      <script src="lib/js/head.min.js"></script>
	  <script src="js/reveal.js"></script>

	  <script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
            //width: 1200,


            controls: true,
				progress: true,
				history: true,
				center: true,
                slideNumber: true,
				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
          			{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'lib/js/jquery-2.2.4.min.js'},
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/external/external.js', condition: function() { return !!document.querySelector( '[data-external]' ); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

            Reveal.addEventListener( 'slidechanged', function( event ) {
//            console.log(event.currentSlide.getAttribute("data-state"))
// if we're on a lab slide, unhide the lab image, otherwise hide it.


            if(event.currentSlide.getAttribute("data-state") === "lab"){
                //document.getElementById("lab_pic").style.visibility="visible";


            if(document.getElementById("lab_pic").style.visibility=="visible"){
                document.getElementById("lab_pic").style.visibility="visible";
            }else{
      $("#lab_pic").css({opacity: 0.0, visibility: "visible"}).animate({opacity: 1}, 200);
            }

            }else{
               //(document.getElementById("lab_pic").style.visibility=="hidden";
               $("#lab_pic").css({opacity: 1.0, visibility: "hidden"}).animate({opacity: 0}, 200);
            }

            } );

		</script>

	</body>
</html>
